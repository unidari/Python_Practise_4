
# **Практическая работа №4. Исследование Python-пакета --- от теоретических основ до публикации в GitHub** {#практическая-работа-4-исследование-python-пакета--от-теоретических-основ-до-публикации-в-github}

## **Цель работы**

**Цель** этой практической работы заключается в изучении принципов
функционирования пакетов в Python и публикации проекта в приватном
репозитории на GitHub.

**Задачи** включают:

1.  Исследование роли файлов `__init__.py` в структуре пакетов.
2.  Освоение работы с модульной структурой Python.
3.  Понимание и применение абсолютного и относительного импорта модулей.
4.  Создание и настройка локального Git-репозитория.
5.  Публикация проекта в приватном репозитории на GitHub с добавлением
    всех необходимых файлов и документации в формате Markdown в
    README.md.
6.  Управление доступом к репозиторию, включая добавление коллаборатора.

Эти задачи помогут вам освоить все этапы работы с Python-пакетами, от их
создания и исследования до управления версиями и совместной работы в
закрытой среде.

## **Задания:**

### **1. Исследование структуры пакета** {#1-исследование-структуры-пакета}

``` plaintext
calculator/
├── __init__.py
├── basic/
│   ├── __init__.py
│   ├── addition.py
│   │   └── def add
│   └── subtraction.py
│       └── def subtract
└── advanced/
    ├── __init__.py
    ├── exponentiation.py
    │   └── def power
    └── root.py
        └── def square_root
```

**б.** Объясните, какую роль играют файлы `__init__.py` в каждом
каталоге пакета. Почему без них пакет не будет работать правильно?

Этот файл является пакетом-проводником, а
не обычной папкой. Без него Python не сможет правильно импортировать
модули из этого каталога. Внутри данного файла можно указывать, какие
модули или функции доступны для импорта. 

### **2. Работа с `__init__.py`** {#2-работа-с-__init__py}

**а.** Обратите внимание на использование переменной `__all__` в файле
`calculator/__init__.py`. Объясните, как она влияет на импорт пакета.

 Данная переменная в файле **init**
определяет, какие модули будут импортироваться при использовании
конструкции from calculator import \*. В данном случае, **all** =
\[\"basic\", \"advanced\"\] означает, что при импорте пакета calculator
будут доступны только эти два подкаталога (basic и advanced), а все
остальные модули или файлы игнорируются. Если даннная переменная не
указана, то Python импортирует все модули, которые есть в пакете, кроме
тех, что начинаются с подчеркивания (\_).
**б.** Удалите или закомментируйте строку
`__all__ = ["basic", "advanced"]` в файле `calculator/__init__.py`.
Попробуйте импортировать пакет снова:

``` python
from calculator import basic
```

Что произошло? Объясните причину возникшей проблемы.
 При попытке выполнить импорт возникла
ошибка. Причина заключается в отсутствии списка доступных для импрта
модулей. Python не смог найти каталог basic в пакете calculator. И при
использовании from calculator import basic не имеет доступа к данному
модулю.

**в.** Верните строку `__all__` обратно. Попробуйте выполнить команду:

``` python
from calculator import *
```

Какие модули будут импортированы? Как можно управлять импортируемыми
модулями с помощью `__all__`?

 После того возвращения переменной **all**
будут импортированы только модули basic и advanced. При использовании
from calculator import \*, Python будет импортировать только те модули,
которые перечислены в **all**.

### **3. Абсолютный и относительный импорт** {#3-абсолютный-и-относительный-импорт}

**а.** В файле `calculator/basic/__init__.py` замените относительные
импорты на абсолютные:

``` python
from calculator.basic.addition import add
from calculator.basic.subtraction import subtract
```

Проверьте работоспособность пакета. Объясните разницу между
относительным и абсолютным импортом. Какие преимущества и недостатки
каждого из них?
 Пакет так же работает. Абсолютный импорт
использует полный путь, а относительный импорт указывает путь
относительно текущего файла с использованием точек. Абсолютный импорт
понятнее, чем относительный, и длиннее, чем относительный.

**б.** Предположим, что структура пакета изменилась, и папка `basic`
была переименована в `simple`. Объясните, как это повлияет на абсолютные
и относительные импорты. Какой импорт легче поддерживать при
реорганизации структуры пакета?

 На абсолютные импорты это сильно повлияет.
Нужно будет поменять все импорты (заменить папку basic на simple).
Относительные импорты могут не изменятся. Например from .root import
square_root останется рабочим. Такой импорт зависит от текущего
местоположения.
### **4. Добавление новых модулей** {#4-добавление-новых-модулей}

**а.** Добавьте в пакет `calculator/basic` новый модуль
`multiplication.py` с функцией `multiply(a, b)`, которая возвращает
произведение `a` и `b`.

 calculator/ ├── **init**.py ├── basic/ │
├── **init**.py │ ├── addition.py │ └── multiplication.py │ └──
subtraction.py └── advanced/ ├── **init**.py ├── exponentiation.py └──
root.py 
**б.** Обновите файл `calculator/basic/__init__.py`, чтобы функция
`multiply` была доступна при импорте пакета.

from calculator.basic.multiplication import
multiply
**в.** В файле `main.py` импортируйте новую функцию и протестируйте ее.

``` python
from calculator.basic import multiply

print(multiply(4, 5))        # Вывод: 20
```
20
### 5. Исследование переменной `__name__` {#5-исследование-переменной-__name__}

**а.** В файле `calculator/advanced/exponentiation.py` добавьте
следующий код:

``` python
if __name__ == "__main__":
    print(power(2, 5))
```
**б.** Запустите файл `exponentiation.py` напрямую. Что произошло? Какой
вывод вы получили?
 Приведённый код позволяет определять точку
входа в программу. Вывод - 32 
**в.** Импортируйте функцию `power` в `main.py` и запустите `main.py`.
Выполняется ли код внутри блока `if __name__ == "__main__":` в файле
`exponentiation.py` при импорте? Объясните, почему.
 Код в файле exponentiation.py не
выполнился, потому что при импорте функции в файле main.py переменная
**name** принимает значение имени модуля, не как значение основного
файла. Код в блоке if **name** == \"**main**\" выполняется, когда файл
запускается напрямую.
### **6. Изучение путей поиска модулей** {#6-изучение-путей-поиска-модулей}
}
**а.** Выведите переменную `sys.path` в `main.py`:

``` python
import sys
print(sys.path)
```

Объясните, какие пути в ней содержатся и как Python использует их для
поиска модулей.

 Текущую директорию, из которой был запущен
скрипт. Директории, указанные в переменной окружения PYTHONPATH.
Стандартные директории, в которых установлены системные пакеты Python.

**б.** Попробуйте переместить папку `calculator` в другую директорию,
которая не входит в `sys.path`. Можете ли вы теперь импортировать пакет?
Что нужно сделать, чтобы Python мог найти ваш пакет?
 Нет, пакет импортировать не получилось.
Для того, чтобы всё-таки найти его, можно добавить новый путь в sys.path
прямо в скрипте, установить переменную окружения PYTHONPATH перед
запуском кода. 

### **8. Практика с относительным импортом** {#8-практика-с-относительным-импортом}

**а.** В файле `calculator/advanced/trigonometry/sine.py` попробуйте
импортировать функцию `square_root` из модуля `root.py` двумя способами:

1.  Используя относительный импорт.
2.  Используя абсолютный импорт.

**б.** Объясните, какой способ импорта сработал, а какой нет, и почему.
 Относительный импорт не сработает.
Относительные импорты работают только внутри пакетов. Абсолютный импорт
сработает всегда, так как всегда указывает полное местоположение модуля,
начиная от корня пакета. В данном случае нам необходимо подняться на
пакет выше, поэтому лучше использовать абсолютный путь.
