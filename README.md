<h1 align="center">Private_task</a>


а. Дополните схему дерева файлов и модулей пакета calculator, указав, какие модули и функции в них содержатся.

calculator/
├── __init__.py
├── basic/
│   ├── __init__.py
│   ├── addition.py
│   └── subtraction.py
└── advanced/
    ├── __init__.py
    ├── exponentiation.py
    └── root.py
calculator/
├── __init__.py
├── basic/
│   ├── __init__.py
│   ├── addition.py
│   │   └── def add
│   └── subtraction.py
│       └── def subtract
└── advanced/
    ├── __init__.py
    ├── exponentiation.py
    │   └── def power
    └── root.py
        └── def square_root
б. Объясните, какую роль играют файлы __init__.py в каждом каталоге пакета. Почему без них пакет не будет работать правильно?

Этот файл является пакетом-проводником, а не обычной папкой. Без него Python не сможет правильно импортировать модули из этого каталога. Внутри данного файла можно указывать, какие модули или функции доступны для импорта.

2. Работа с __init__.py
а. Обратите внимание на использование переменной __all__ в файле calculator/__init__.py. Объясните, как она влияет на импорт пакета.

Данная переменная в файле __init__ определяет, какие модули будут импортироваться при использовании конструкции from calculator import *. В данном случае, __all__ = ["basic", "advanced"] означает, что при импорте пакета calculator будут доступны только эти два подкаталога (basic и advanced), а все остальные модули или файлы игнорируются. Если даннная переменная не указана, то Python импортирует все модули, которые есть в пакете, кроме тех, что начинаются с подчеркивания (_).
б. Удалите или закомментируйте строку __all__ = ["basic", "advanced"] в файле calculator/__init__.py. Попробуйте импортировать пакет снова:


[ ]
from calculator import basic
Что произошло? Объясните причину возникшей проблемы.

При попытке выполнить импорт возникла ошибка. Причина заключается в отсутствии списка доступных для импрта модулей. Python не смог найти каталог basic в пакете calculator. И при использовании from calculator import basic не имеет доступа к данному модулю.
в. Верните строку __all__ обратно. Попробуйте выполнить команду:


[ ]
from calculator import *
Какие модули будут импортированы? Как можно управлять импортируемыми модулями с помощью __all__?

После того возвращения переменной __all__ будут импортированы только модули basic и advanced. При использовании from calculator import *, Python будет импортировать только те модули, которые перечислены в __all__.
3. Абсолютный и относительный импорт
а. В файле calculator/basic/__init__.py замените относительные импорты на абсолютные:


[ ]
from calculator.basic.addition import add
from calculator.basic.subtraction import subtract
Проверьте работоспособность пакета. Объясните разницу между относительным и абсолютным импортом. Какие преимущества и недостатки каждого из них?

Пакет так же работает. Абсолютный импорт использует полный путь, а относительный импорт указывает путь относительно текущего файла с использованием точек. Абсолютный импорт понятнее, чем относительный, и длиннее, чем относительный.
б. Предположим, что структура пакета изменилась, и папка basic была переименована в simple. Объясните, как это повлияет на абсолютные и относительные импорты. Какой импорт легче поддерживать при реорганизации структуры пакета?

На абсолютные импорты это сильно повлияет. Нужно будет поменять все импорты (заменить папку basic на simple). Относительные импорты могут не изменятся. Например from .root import square_root останется рабочим. Такой импорт зависит от текущего местоположения.
4. Добавление новых модулей
а. Добавьте в пакет calculator/basic новый модуль multiplication.py с функцией multiply(a, b), которая возвращает произведение a и b.

calculator/ ├── __init__.py ├── basic/ │ ├── __init__.py │ ├── addition.py │ └── multiplication.py │ └── subtraction.py └── advanced/ ├── __init__.py ├── exponentiation.py └── root.py
б. Обновите файл calculator/basic/__init__.py, чтобы функция multiply была доступна при импорте пакета.

from calculator.basic.multiplication import multiply

в. В файле main.py импортируйте новую функцию и протестируйте ее.


[ ]
from calculator.basic import multiply

print(multiply(4, 5))        # Вывод: 20
20

5. Исследование переменной __name__
а. В файле calculator/advanced/exponentiation.py добавьте следующий код:


[ ]
if __name__ == "__main__":
    print(power(2, 5))
б. Запустите файл exponentiation.py напрямую. Что произошло? Какой вывод вы получили?

Приведённый код позволяет определять точку входа в программу. Вывод - 32
в. Импортируйте функцию power в main.py и запустите main.py. Выполняется ли код внутри блока if __name__ == "__main__": в файле exponentiation.py при импорте? Объясните, почему.

Код в файле exponentiation.py не выполнился, потому что при импорте функции в файле main.py переменная __name__ принимает значение имени модуля, не как значение основного файла. Код в блоке if __name__ == "__main__" выполняется, когда файл запускается напрямую.
6. Изучение путей поиска модулей
а. Выведите переменную sys.path в main.py:


[ ]
import sys
print(sys.path)
Объясните, какие пути в ней содержатся и как Python использует их для поиска модулей.

Текущую директорию, из которой был запущен скрипт. Директории, указанные в переменной окружения PYTHONPATH. Стандартные директории, в которых установлены системные пакеты Python.
б. Попробуйте переместить папку calculator в другую директорию, которая не входит в sys.path. Можете ли вы теперь импортировать пакет? Что нужно сделать, чтобы Python мог найти ваш пакет?

Нет, пакет импортировать не получилось. Для того, чтобы всё-таки найти его, можно добавить новый путь в sys.path прямо в скрипте, установить переменную окружения PYTHONPATH перед запуском кода.
7. Создание подпакетов
а. Внутри calculator/advanced создайте подпакет trigonometry с функциями sin, cos и tan. Структура должна выглядеть так:


[ ]
calculator/
└── advanced/
    ├── trigonometry/
    │   ├── __init__.py
    │   ├── sine.py
    │   ├── cosine.py
    │   └── tangent.py
б. Реализуйте функции в соответствующих модулях, используя модуль math из стандартной библиотеки Python.

в. Обновите __init__.py файлы, чтобы обеспечить корректный импорт функций.

г. Импортируйте функции в main.py и протестируйте их.

8. Практика с относительным импортом
а. В файле calculator/advanced/trigonometry/sine.py попробуйте импортировать функцию square_root из модуля root.py двумя способами:

Используя относительный импорт.
Используя абсолютный импорт.
б. Объясните, какой способ импорта сработал, а какой нет, и почему.

Относительный импорт не сработает. Относительные импорты работают только внутри пакетов. Абсолютный импорт сработает всегда, так как всегда указывает полное местоположение модуля, начиная от корня пакета. В данном случае нам необходимо подняться на пакет выше, поэтому лучше использовать абсолютный путь.
